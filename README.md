clean architecture

implementing clean architecture: project consists of three layers: data, domain and presentation. 
data layer is implementation of data sources(api services and local databases) and repositories, repository is just an abstraction of data sources and object that centralizes data access of same data model.
domain layer is implementation of application bussiness rules, it consists of useCases and domain models, domain model is object that represents app bussiness rules, it's structure is suitable for whole app. single useCase is an implementation of single data flow logic, useCase can be depended on one or many repositories, it can chain many repository methods as well, so real reason why repository pattern is implemented is that, each repository method exists only because it is supporting a useCase.
these layers ar implemented in separate modules, the reason for this is to provide proper dependensies, that is one of main purpose of clean architecture.
data module is andoid module, it implements data sources with platform specific components. data module is depended on domain module, reason is to implement repositories, since repository is supposed to be middle man between data and domain layers, contract of repositories is part of domain module, reason is that domain is higher level layer than data layer, to implement repositories data module also needs to know what domain models are, because repository should only receive and return domain models, it's part of abstraction of data access, that's main point of repository.
domain module is plain kotlin/java module, it's independent from platform and rest of project as well. domain module has also contracts of repositories to provide its dependency to useCases.

MVI design

presentation layer is implementation of MVI design pattern, main concepts of this pattern are following:
models are formalized as containers of state, state is single presentation unit's current condition, states are imutable, new states are created from latest state, that's called state reducing, it provides conscise way of updating ui, it's like single source of truth, which is lifecycle-aware and can be completely restored after recreating of components or it's view.
presentation layer's each item consists of view and presenter, whole process from receiving action from user to updating ui is asynchronous, presenters are observing to actions(intents) returning from view and views are observing state returning from presenter, presenters are processing actions and updationg state on their own or with domain layer, which is also asynchronous.

implementation: states and actions are both kotlin sealed classes, sealed classes gives you ability to create enumeration of objects, classes or other sealed classes and make abstraction of them under single type, states are additionally holding a object that is container of all data that any state needs, it's a kotlin data class, when state is restored that object is passed to ui element. states also are implementing state reducers optionally, if state is holding any kind of data, state should copy state model object to create new object holding all data from previous plus new state's data, states also are providing the initialization of state model.
fragments are used as views and viewModels as presenters, both of them are holding types of actions and viewStates, fragments also are holding type of viewModel to provide it's dependency, fragments declare subject for actions, which view models are observing since fragments are first attached. viewModels are declaring subjects for state and stateModel, which fragents are observing since they are first attached. viewModels are also holding single state model, which is updated every time fragment receives new state, every time fragment view is created, viewModels are notified and they check if state model is initializes, if it isn't initialized, that's first time when fragment view is created, so onDraw method is called with passed state model as null, if state model is initialized when fragment view is created, that means that fragment or it's view recreated, so onDraw methos is called with passed latest state model. fragment has postAction method to pass action to viewModel and reflectState method for receiving states from viewModel, viewModel has postState method to pass new state to fragment and onActionReceived to receive action from fragment.

single activity design

presentation units are only fragments, there is only single default activity that takes responsibility to host and manage all fragments, main advantages we get from implementing this design are: easier navigation between presentation units, handling application-wide events and sharing data, we achieve this by having viewModel for default activity, whose dependency can by shared in all hosted fragments' viewModels, that way fragments don't interact with default activity or it's viewModel directly, which handles all the application-wide events, to follow interface segregation and single responsibility principles, activity's viewModel can implement different types for different group of events, for example, implementing FragmentNavigator for handling navigation for fragments, each of this type is shared separately in fragments' viewModels, so fragments do not know who is standing back of those process, 

dependency injection

project has single dependency graph which mainly has three levels, on top of it hierarchy is application-wide(singleton) dependencies, then comes activity-wide dependencies(provided until process is killed or configuration is changed), at bottom of this graph is fragment-wide dependencies (provided until presentation unit is alive).
to implement this, google's Dagger framework is used, for providing this dependencies each level item on this graph has its component, which are bound to proper android components(application, activity, and fragments), the meaning of binding is that creating its instance and providing its dependencies are depended on proper android components lifecycle, which is called a scope. every android component that has dagger component can inject objects that they are depended on. injecting objects can be done when providing other dependencies, when those objects are depended on other objects that are also provided in graph.

asynchronous flows

as mentioned above, whole process from receiving action from user to updating ui is asynchronous, to achieve this RxJava framework is used, it's subjects give you ability to implement observer pattern easily, operators for this subjects enables you to write all the heavy logic following to functional programing, that makes code to be more conscise and easy to understand and maintain, it also provides easier way for error handling and managing threads.
implementation: data/domain layer - all data souces has support for RxJava, that enables you to implement observer pattern for data flow. data sources and repository as well as useCases are ruturning data only as observable, also one of main point there is that all the flow is executed away from main thread, that is managed by RxJava schedulers.
as written above, actions from view and states from presenter are returned as observable, so there is only two subscribers in all this flow: view subscribing for states and presenter subscribing for actions, there aslo could be two places in all this flow where heavy chain operators and merging of subject can be done: they are useCases - handling bussines logic with repository and presentation - handling applicaton logic with actions and useCases.

errror handling and navigation

as written above activity's viewModel is implementing Error and Navigation handlers, which handles proper event types, and they are shared in fragments' viewModels separately,
implementation: in viewModel, subject of actions' and all the useCases merging and producing new state has single subscriber that is sending state to fragment, so all the error handling in this process is written by single operator, that makes proper error type from exception and pass the error handler, which is activity's viewModel. on ather hand when view has navigation action, it does not know who actually precesses this action, it only passes this action to it's viewModel as regular action, ther it's viewModel checks if it is navigation action and passes to navigation handler, which is activity's viewModel as well.
